<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>Insightful Verse - AiBot</title>
  <th:block th:replace="~{common/sub/iviep/iviep-common.html}"></th:block>
  <style>
    body {
      background-color: #0071C5; /* Intel科技蓝 */
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem 2rem;
      min-height: 0;
    }
    #chat-history {
      flex: 1;
      background: #C4C4C4; /* 介于浅灰色和灰色之间 */
      border: 1px solid #ced4da;
      border-radius: 10px;
      padding: 1rem;
      overflow-y: auto;
      font-family: monospace;
    }
    /* Custom Scrollbar Styles */
    #chat-history::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    #chat-history::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    #chat-history::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }
    #chat-history::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .message {
      margin-bottom: 0.25rem;
    }
    .user {
      font-weight: bold;
      color: #0d6efd;
    }
    .ai {
      font-weight: bold;
      color: #198754;
    }
    .content {
      white-space: pre-wrap;
      margin-left: 0.5rem;
      display: inline-block;
      line-height: 1.4;
    }
    /* 新增的可折叠内容样式 */
    .collapsible-content {
      max-height: 4.2em; /* 约 3 行文字 (1.4 * 3 = 4.2) */
      overflow: hidden;
      position: relative;
    }
    .collapsible-content.expanded {
      max-height: none;
      overflow: visible;
    }
    .show-more-button {
      color: #007bff;
      cursor: pointer;
      margin-left: 0.5rem;
      font-size: 0.9em;
      text-decoration: underline;
    }

    .input-area {
      padding: 1rem 2rem;
      background: #C0C0C0; /* 介于浅灰色和灰色之间 */
      border-top: 1px solid #ced4da;
      display: flex;
      align-items: flex-start;
    }
    .input-area textarea {
      flex: 1;
      resize: none;
      min-height: 3rem;
      max-height: 10rem;
      overflow-y: hidden;
      margin-right: 1rem;
      padding: 0.5rem 0.75rem;
      line-height: 1.5;
      box-sizing: border-box;
    }
    .input-area button {
      margin-left: 0.5rem;
      align-self: flex-end;
      margin-bottom: 0.375rem;
    }
  </style>
</head>
<body>
<th:block th:replace="~{common/sub/iviep/iviep-header-intel.html}"></th:block>

<div class="chat-container">
  <div id="chat-history"></div>
</div>

<div class="input-area">
  <textarea id="prompt" class="form-control" placeholder="Type your message..."></textarea>
  <button class="btn btn-primary" onclick="sendPrompt()">Send</button>
  <button class="btn btn-warning" onclick="interruptGeneration()">Stop</button> <button class="btn btn-danger" onclick="clearResponse()">Clear</button>
  <button class="btn btn-secondary" onclick="exportChat()">Export Chat</button>
</div>

<script>
  const promptEl = document.getElementById("prompt");
  const initialMinHeight = window.getComputedStyle(promptEl).minHeight;
  let currentEventSource = null; // 用于存储当前的 EventSource 实例

  promptEl.addEventListener("input", function() {
    this.style.height = 'auto';
    let scrollHeight = this.scrollHeight;
    const maxHeight = parseInt(window.getComputedStyle(this).maxHeight, 10);

    if (maxHeight && scrollHeight > maxHeight) {
      this.style.height = maxHeight + 'px';
      this.style.overflowY = 'auto';
    } else {
      const minHeightVal = parseInt(initialMinHeight, 10);
      if (scrollHeight < minHeightVal) {
        this.style.height = initialMinHeight;
      } else {
        this.style.height = scrollHeight + 'px';
      }
      this.style.overflowY = 'hidden';
    }
  });

  async function sendPrompt() {
    const text = promptEl.value.trim();
    if (!text) return;

    promptEl.value = "";
    promptEl.style.height = initialMinHeight;
    promptEl.style.overflowY = 'hidden';

    const chatHistory = document.getElementById("chat-history");

    // 添加用户消息到聊天历史
    const userDiv = document.createElement("div");
    userDiv.className = "message";
    const userTextNode = document.createTextNode(text);
    const userPrefix = document.createElement("span");
    userPrefix.className = "user";
    userPrefix.textContent = "You: ";
    const userContent = document.createElement("span");
    userContent.className = "content";
    userContent.appendChild(userTextNode);
    userDiv.appendChild(userPrefix);
    userDiv.appendChild(userContent);
    chatHistory.appendChild(userDiv);

    // 添加 AI 消息容器 (流式接收内容)
    const aiDiv = document.createElement("div");
    aiDiv.className = "message";
    const aiContentId = "ai-" + Date.now();
    const aiPrefix = document.createElement("span");
    aiPrefix.className = "ai";
    aiPrefix.textContent = "AiBot: ";
    const aiContentSpan = document.createElement("span");
    aiContentSpan.className = "content collapsible-content"; // 添加可折叠类
    aiContentSpan.id = aiContentId;
    aiDiv.appendChild(aiPrefix);
    aiDiv.appendChild(aiContentSpan);
    chatHistory.appendChild(aiDiv);

    chatHistory.scrollTop = chatHistory.scrollHeight;

    // 如果有旧的 EventSource 实例在运行，先关闭它
    if (currentEventSource) {
      console.warn("Closing previous EventSource before starting a new one.");
      currentEventSource.close();
      currentEventSource = null; // 清除旧的引用
    }

    // 使用 EventSource 连接 SSE 端点
    // URL 路径匹配 Java Controller 的 @RequestMapping 和 @GetMapping
    // prompt 作为查询参数传递，因为 Controller 是 GET 请求
    const url = `/InsightfulVerse/AiBot/stream?prompt=${encodeURIComponent(text)}`;
    currentEventSource = new EventSource(url);

    let fullAiResponse = ""; // 累积完整的AI响应

    // 监听 SSE 接收到的消息
    currentEventSource.onmessage = function(event) {
      const textChunk = event.data; // 接收到的数据
      // 检查服务器发送的中断标记
      if (textChunk === "[STOP]") {
        console.log("AI stream stopped by server due to interruption.");
        aiContentSpan.textContent += " [Generation Stopped]"; // 提示用户
        currentEventSource.close(); // 收到停止标记，关闭 EventSource
        return; // 立即返回，不再处理后续数据
      }

      fullAiResponse += textChunk;
      aiContentSpan.textContent = fullAiResponse; // 更新内容
      chatHistory.scrollTop = chatHistory.scrollHeight; // 滚动到底部
    };

    // 监听 SSE 错误
    currentEventSource.onerror = function(error) {
      console.error('EventSource failed:', error);
      aiContentSpan.textContent += " [Error occurred or connection closed]";
      currentEventSource.close(); // 发生错误时关闭连接
      chatHistory.scrollTop = chatHistory.scrollHeight;
    };

    // 监听 SSE 连接打开
    currentEventSource.onopen = function() {
      console.log('EventSource connected.');
    };

    // 监听 SSE 连接关闭
    currentEventSource.onclose = function() {
      console.log('EventSource disconnected.');
      // Stream 完成或被中断后，检查最终内容是否需要折叠
      checkAndApplyCollapsible(aiContentSpan, aiDiv);
      currentEventSource = null; // 清除引用
    };
  }

  // 新增的中断函数
  async function interruptGeneration() {
    if (currentEventSource) {
      // 先关闭客户端的 EventSource 连接，停止接收数据
      currentEventSource.close();
      console.log("Client-side EventSource closed.");
      // 然后向后端发送中断信号，通知Java后端，进而通知Python后端停止生成
      try {
        const res = await fetch("/InsightfulVerse/AiBot/interrupt", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({}) // 发送空JSON体
        });
        const data = await res.json();
        console.log("Interrupt API response:", data.message);
      } catch (error) {
        console.error("Error sending interrupt signal to backend:", error);
      } finally {
        currentEventSource = null; // 清除引用
      }
    } else {
      console.log("No active AI stream to interrupt.");
    }
  }

  // 检查并应用/移除折叠功能 (从之前的代码复制过来)
  function checkAndApplyCollapsible(contentElement, parentMessageDiv) {
    // 确保在内容完全渲染后才检查scrollHeight
    setTimeout(() => {
      // 如果内容高度超过了设定最大高度（4.2em）
      const lineHeight = parseFloat(window.getComputedStyle(contentElement).lineHeight);
      const maxHeightLines = 3; // 设置为3行
      const maxHeightPx = lineHeight * maxHeightLines;

      // 暂时移除 max-height 样式，以便正确计算 scrollHeight
      const originalMaxHeight = contentElement.style.maxHeight;
      const originalOverflow = contentElement.style.overflow;
      contentElement.style.maxHeight = 'none';
      contentElement.style.overflow = 'visible';

      const currentScrollHeight = contentElement.scrollHeight;

      // 恢复原始样式
      contentElement.style.maxHeight = originalMaxHeight;
      contentElement.style.overflow = originalOverflow;


      if (currentScrollHeight > maxHeightPx) {
        if (!contentElement.classList.contains("collapsible-content")) {
          contentElement.classList.add("collapsible-content"); // 确保类存在
        }
        // 检查是否已经有 "Show More" 按钮
        let showMoreBtn = parentMessageDiv.querySelector(".show-more-button");
        if (!showMoreBtn) {
          showMoreBtn = document.createElement("span");
          showMoreBtn.className = "show-more-button";
          showMoreBtn.textContent = "Show More";
          showMoreBtn.onclick = function() {
            contentElement.classList.toggle("expanded");
            if (contentElement.classList.contains("expanded")) {
              showMoreBtn.textContent = "Show Less";
            } else {
              showMoreBtn.textContent = "Show More";
            }
            document.getElementById("chat-history").scrollTop = document.getElementById("chat-history").scrollHeight;
          };
          parentMessageDiv.appendChild(showMoreBtn); // 将按钮添加到消息的父div
        }
      } else {
        // 如果内容没超过高度，移除折叠样式和按钮
        contentElement.classList.remove("collapsible-content", "expanded");
        let showMoreBtn = parentMessageDiv.querySelector(".show-more-button");
        if (showMoreBtn) {
          showMoreBtn.remove();
        }
      }
    }, 50); // 小延迟确保渲染
  }


  function clearResponse() {
    document.getElementById("chat-history").innerHTML = "";
    if (currentEventSource) {
      currentEventSource.close(); // 清除时也关闭 EventSource 连接
      currentEventSource = null;
    }
  }

  function exportChat() {
    const chatHistory = document.getElementById("chat-history");
    let chatContent = "";
    const messages = chatHistory.children;

    for (let i = 0; i < messages.length; i++) {
      const messageElement = messages[i];
      const speakerElement = messageElement.querySelector(".user, .ai");
      // 获取折叠前的原始内容，而不是当前的显示内容
      const contentElement = messageElement.querySelector(".content");
      let actualContent = contentElement.textContent;

      // 移除可能添加的 "[Generation Stopped]" 等标记
      if (actualContent.endsWith(" [Generation Stopped]")) {
        actualContent = actualContent.slice(0, -21);
      } else if (actualContent.endsWith(" [Error occurred or connection closed]")) {
        actualContent = actualContent.slice(0, -37);
      }

      if (speakerElement && contentElement) {
        let speakerText = speakerElement.textContent;
        if (!speakerText.endsWith(" ")) speakerText += " ";
        chatContent += speakerText + actualContent + "\n\n";
      }
    }

    if (chatContent.trim() === "") {
      alert("Nothing to export!");
      return;
    }

    const blob = new Blob([chatContent], { type: "text/plain;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    const timestamp = new Date().toISOString().replace(/:/g, "-").slice(0, 19);
    a.download = `chat-export-${timestamp}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }

  document.getElementById("prompt").addEventListener("keydown", function(event) {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      sendPrompt();
    }
  });
</script>
</body>
</html>